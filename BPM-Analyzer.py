print("起動中...",end='')
from pydub import AudioSegment, silence
from tqdm import tqdm
import os
import librosa
import numpy as np
import glob
from pytube import YouTube

import matplotlib.pyplot as plt

if os.name == 'nt':
    import ctypes
 
    # https://docs.microsoft.com/en-us/windows/console/setconsolemode?redirectedfrom=MSDN
    ENABLE_PROCESSED_OUTPUT = 0x0001
    ENABLE_WRAP_AT_EOL_OUTPUT = 0x0002
    ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004
    MODE = ENABLE_PROCESSED_OUTPUT + ENABLE_WRAP_AT_EOL_OUTPUT + ENABLE_VIRTUAL_TERMINAL_PROCESSING
 
    kernel32 = ctypes.windll.kernel32
    handle = kernel32.GetStdHandle(-11)
    kernel32.SetConsoleMode(handle, MODE)

#Set Colour Variables
red="\033[31m"
blue="\033[34m"
cyan="\033[36m"
yellow="\033[33m"
green="\033[32m"
purple="\033[35m"
bold="\033[1m"
end="\033[0m"


def cut_silence_at_start(filename):
    print(f"{cyan}Cutting Silence...{end}")
    filesuffix = filename.split(".")[-1]
    sound = AudioSegment.from_file(filename, format=filesuffix)
    start_trim = silence.detect_leading_silence(sound)
    end_trim = silence.detect_leading_silence(sound.reverse())
    duration = len(sound)    
    trimmed_sound = sound[start_trim:duration-end_trim]
    filename = filename.replace(".mp3","")
    os.makedirs(f"output/{filename}_output", exist_ok=True)
    trimmed_sound.export(f"output/{filename}_output/{filename}_cut.wav", format="wav")
    return(filename)

def cut_sound_file(filename, number):
    filesuffix = filename.split(".")[-1]
    sound = AudioSegment.from_file(filename, format=filesuffix)
    sec=sound.duration_seconds
    print(f"{yellow}Total Time(s) : ",end, sec)
    seq=sec/int(number) 
    seq=round(seq)
    start=0
    
    for i in range(seq):
        ends=start+int(number)
        sound_part = sound[start*1000:ends*1000]
        sound_part.export(f"output/{filename}_output/{i}.wav", format="wav")
        print(f"{yellow}{i}.wav --> {green}OK!")
        start = ends
    return(seq)

def analyze_bpm_swing(filename,seq,export,remain):
    print("BPMを測定中...")
    print(cyan+"BPM")
    if export == True:
        with open(f"output/{filename}_output/{filename}_bpm.txt", "w") as f:
            f.write(f"# This file was generated by BPM-Analyzer ver 2.7.0 (@Kokohachi)\n# BPM_{filename}\n#Sequence:{seq}\n")
    for i in range(seq):
        
        duration = 10
        x_sr = 200
        bpm_min, bpm_max = 30, 300
        filepath = f"output/{filename}_output/{i}.wav"
        # 楽曲の信号を読み込む

        y, sr = librosa.load(filepath)

        # ビート検出用信号の生成
        # リサンプリング & パワー信号の抽出
        x = np.abs(librosa.resample(y, sr, x_sr)) ** 2
        x_len = len(x)

        # 各BPMに対応する複素正弦波行列を生成
        M = np.zeros((bpm_max, x_len), dtype=complex)
        for bpm in range(bpm_min, bpm_max): 
            thete = 2 * np.pi * (bpm/60) * (np.arange(0, x_len) / x_sr)
            M[bpm] = np.exp(-1j * thete)

        # 各BPMとのマッチング度合い計算
        #（複素正弦波行列とビート検出用信号との内積）
        x_bpm = np.abs(np.dot(M, x))

        # BPM　を算出
        bpm = np.argmax(x_bpm)
        print(f"{yellow}{i}.wav --> BPM : ",end, bpm)
        if export == True:
            with open(f"output/{filename}_output/{filename}_bpm.txt", mode="a") as f:
                f.write(f"{i} --> BPM : {bpm}\n")
        
    if remain == False:
        for file in glob.glob(f'output/{filename}_output/*.wav'):
            os.remove(file)

def analyze_bpm(filepath):
    print("BPMを測定中...")
    duration = 30
    x_sr = 200
    bpm_min, bpm_max = 30, 300
    # 楽曲の信号を読み込む

    y, sr = librosa.load(filepath, offset=38, duration=duration, mono=True)

    # ビート検出用信号の生成
    # リサンプリング & パワー信号の抽出
    x = np.abs(librosa.resample(y, sr, x_sr)) ** 2
    x_len = len(x)

    # 各BPMに対応する複素正弦波行列を生成
    M = np.zeros((bpm_max, x_len), dtype=complex)
    for bpm in range(bpm_min, bpm_max): 
        thete = 2 * np.pi * (bpm/60) * (np.arange(0, x_len) / x_sr)
        M[bpm] = np.exp(-1j * thete)

    # 各BPMとのマッチング度合い計算
    #（複素正弦波行列とビート検出用信号との内積）
    x_bpm = np.abs(np.dot(M, x))

    # BPM　を算出
    bpm = np.argmax(x_bpm)
    return(bpm)
            
def youtube_download(URL):
    print(f"{cyan}Downloading...{end}")
    yt = YouTube(URL)
    stream = yt.streams.get_by_itag('140')
    stream.download()
    return(stream.default_filename)
        
print(
f"""
\033[1A\r{yellow}== {end}BPM-Analyzer{yellow} -----------------------------------------------------------
    {yellow}BPM-Analyzer/ BPM解析ツール{end}
    {cyan}Version:{end} 0.2.7
    {cyan}Developed by:{end}ここはち(@Kokohachi)
    {cyan}Repository:{end}https://github.com/Kokohachi/BPM-Analyzer
{yellow}-------------------------------------------------------------------------------{end}
""".strip()
)

file = os.path.exists("output")
if file == True:
    print(f"{yellow}Output Directory Exist? -> {green}{file}{end}")

if file == False:
        #保存先ディレクトリの作成
    print(f"{yellow}Output DirectoryExist? -> {red}{file}{end}")
    os.mkdir("output")
    print(f"{green}Output Directory Created.{end}")

filename = input(f'{yellow}Filename or YouTube Link-> {end}')
if "https://" in filename:
    filename = youtube_download(filename)
    if "/" in filename:
        filenames = filename.replace("/", "-")
        os.rename(filename,filenames)
        filename = filenames
    print(f"{cyan}Downloaded ->{end} {filename}")
    convert = input(f'{yellow}Convert to mp3?(y/n) {end}')
    if convert == "y":
        #Use Pydub to Convert to mp3
        print(f"{cyan}Converting to mp3...{end}")
        sourceAudio = AudioSegment.from_file(filename, "mp4")
        sourceAudio.export(filename.replace(".mp4", ".mp3"), format="mp3")
        print(f"{cyan}Converted to mp3.{end}")
    #cut silence
dic={'y':True,'yes':True,'n':False,'no':False}
cut = input(f'{yellow}Cut Silence?(y/n) {end}')
if dic[cut] == True:
    print(f"{cyan}Cutting Silence...{end}")
    cut_silence_at_start(filename)
    print(f"{cyan}Done cutting Silence ({filename}).{end}")
swing = dic[input(f'{yellow}Swing(Y/N) -> {end}').lower()]
if swing == True:
    sequence = input(f'{yellow}Separate by -> {end}')
    remain = dic[input(f'{yellow}Remain Devided Sound Files?(Y/N) -> {end}').lower()]
    export = dic[input(f'{yellow}Export BPM Data?(Y/N) -> {end}').lower()]
    qqq=cut_sound_file(filename, sequence)
    print(f"{cyan}Sequence(s)->{end}{qqq}")
    analyze_bpm_swing(filename,qqq,export,remain)
elif swing == False:
    bpm = analyze_bpm(filename)
    print(f"{cyan}BPM -> {end}{bpm}")
else:
    print(f"{red}Error!{end}")
    print(f"{red}Please input Y or N.{end}")
    sys.exit()
print(f"{yellow}== {end}BPM-Analyzer{yellow} -----------------------------------------------------------{end}")
input(f"{yellow}Press Enter to Exit.{end}")
